# EDU_back
jpa
핵심 2가지
1. 연관관계 매핑
2. 영속성 컨텍스트
   
J2SE 환경
엔티티 매니저와 영속성컨텍스트가 1:1
J2EE, 스프링 프레임워크 같은 컨테이너 환경
엔티티 매니저와 영속성 컨텍스트가 N:1
(엔티티 매너지가 있으면 영속성 컨텍스트가 내부에 있음, 캐시 같은놈이구나)
엔티티의 생명주기(엔티티 매니저 = 영속 컨텍스트  -> 우선 이렇게 이해)

객체를 생성한 상태 = 비영속



패러다임 불일치
생산성 - jpa와 crud
저장 : jpa.persist(member))
조회 : Member member = jpa.find(memberld)
수정 : member.setName("변경할 이름')
삭제 : jpa.remove(member)

transaction.
= sql문을 모아서 한번에 처리

지연로딩과 즉시로딩
지연로딩 : 객체가 실제 사용될 떄 로딩
즉시로딩 : json sql로 하번에 연관된 객체까지 미리 죄회

jpa 영속성 컨텍스트
@Entity db랑 매핑하는 클래스
@id db의 pk랑 매핑하는 거(객체?)

마이바티스
sql쿼리를 내가 직접 짜서 넣어줘야 됨
퀴리를 객체로 매핑해주는일을 함

영속 엔티티의 동일성 보장
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");
System.out.println(a == b); //동일성 비교 true
1차 캐시로 반복 가능한 읽기(REPEATABLE READ)등급의 트랜젝션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공
-> 영속컨텐스트 안에는 1차 캐시가 있다 그렇기 때문에 a와 b는 1차 캐시에서 모두 조회된다(db에서 조회되지 않고)
이해가 안된다면? 1. find("member1) 1차캐시에서 우선 조회 -> 2. db조회 3. 1차캐시에 저장 4. 반환
member a -> 1차캐시에 저장됨 member b = db 조회 x (1차캐시에 남아 있는 member1) 1차캐시에서 바로 반환
1차캐시 -> 영속상태

엔티티 수정 
변경 감지

연관관계 매핑
manytoone은 항상 연관관계의 주인이 되므로 mappedby를 설정할 수 없다. 따라서 manytoone에는 mappedby 속성이 없다
단방향 매핑과 비교해서 양방향 매핑은 복잡하다. 연관관계의 주인도 정해야하고, 두 개의 단방향 연관관계를 양방향으로 만들기 위해 로직도 잘 관리해야 한다
중요한 사실은 연관관계가 하나인 단방향 매피은 언제나 연관관계의 주인이라는 점이다. 양방향은 여기에 주인이 아닌 연관관계를 하나 추가했을 뿐이다. 
결국 단방향과 비교해서 양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것 뿐이다. 
//